Производительная и надежная клиент-серверная реляционная СУБД, используется для обработки транзакционных данных и управления разными типами информации. Которая строго соблюдает принципы ACID и предоставляет широкие возможности по индексированию данных.
## Архитектура
PostgreSQL построен по многопроцессной клиент-серверной модели с разделяемой памятью, что обеспечивает высокую надежность, производительность и масштабируемость.
### Основные компоненты архитектуры
#### Postmaster - главный процесс
Единственный узел который принимает запросы на запись, записывает все изменения в WAL.
Центральный управляющий процесс, который:
- Запускается первым при старте PostgreSQL
- Прослушивает входящие подключения клиентов
- Аутентифицирует пользователей через конфигурационные файлы (pg_hba.conf)
- Создает отдельный backend-процесс для каждого клиентского подключения
- Управляет фоновыми процессами

#### Backend-процессы (Postgres Server Process)
Узел, который получает WAL с мастера и применяет их к своей копии данных.
Каждому клиентскому подключению соответствует отдельный backend-процесс, который:
- Обрабатывает SQL-запросы от клиента
- Выполняет весь цикл обработки: парсинг → переписывание → планирование → выполнение
- Имеет собственную локальную память (work_mem, temp_buffers, maintenance_work_mem)
- Взаимодействует с общей памятью для доступа к данным
Существуют физические (полная копия данных мастера), Логические (только изменения под логической подпиской, реплика только части таблицы преобразования)
#### Разделяемая память (Shared Memory)
Критически важный компонент, включающий:
- **Shared Buffer Pool** - кеш страниц данных из таблиц и индексов. Область в памяти куда загружаются страницы (по 8 кб) с диска, для работы с ними.
- **WAL Buffer** - буфер для журнала транзакций (Write-Ahead Log), для WAL-записей перед сбросом в WAL-файл.
- **CLOG (Commit Log)** - информация о состоянии транзакций
- os cache - кэш на уровне os
- Кэш каталогов - кэширует метаинформацию о таблицах, индексах, функциях
- Кэш плана запросов - функции и выражения могут кэшировать свои планы выполнения.

#### Фоновые процессы
Выполняют служебные задачи для поддержания производительности и надежности:
- **BGWriter** - записывает "грязные" страницы из буферов на диск постепенно
- **WAL Writer** - записывает WAL-записи на диск
- **Checkpointer** - выполняет контрольные точки для обеспечения согласованности. Процесс при котором все "грязные" страницы сбрасываются на диск. Сокращает время восстановления после сбоя, точка до которой можно безопасно удалять/архивировать WAL.
- **Autovacuum** - автоматическая очистка и обновление статистики, состоит из: **vacuum** - убирает мертвые кортежи, освобождая место для новых, место помечается как доступное для записи; **analyze** - статистика о распределении данных в таблицах, важна для планирования запросов.
- **Stats Collector** - сбор статистики производительности
- **Archiver** - архивирование WAL-файлов для репликации

#### Хранилище данных
Физическое хранение включает:
- **Файлы данных** - таблицы и индексы
- **WAL-файлы** - журнал транзакций для восстановления. Журнал предзаписи. Любое изменение сначала записывается в WAL-файл, только потом в сами таблицы. Обеспечивает долговечность, после записи транзакция устойчива даже при сбоях питания. Восстановление, тк при старте PSQL считывает WAL, что бы привести базу в состояние на момент последней проверки. WAL переписывается на реплики. Сегмент WAL - файл размером 16мб, когда он заканчивается создается новый.
- **Конфигурационные файлы** - настройки сервера
- **Журналы** - логи активности и ошибок


### Процесс обработки запроса
1. **Подключение**: Клиент подключается через libpq к Postmaster
2. **Аутентификация**: Postmaster проверяет права доступа
3. **Создание backend**: Создается выделенный процесс для клиента
4. **Обработка запроса**:
    - Парсинг SQL-команды
    - Перезапись запроса (применение правил и представлений)
    - Планирование и оптимизация
    - Выполнение через executor
5. **Доступ к данным**: Взаимодействие с shared buffers и дисковыми файлами
6. **Возврат результата**: Отправка ответа клиенту

Эта архитектура обеспечивает изоляцию процессов, эффективное использование памяти и высокую надежность за счет независимости backend-процессов и журналирования транзакций.


### Индексы
Индексы - структуры данных, которые ускоряют поиск информации в таблицах. Без индекса PSQL вынужден выполнять полное сканирование таблицы (Sequental Scan), что неэффективно для больших таблиц.
#### Типы индексов
Поддерживается несколько типов индексов, каждый оптимизирован для определенных типов запросов.

**B-Tree индексы (по умолчанию)**
Это сбалансированное дерево, наиболее универсальный тип индекса.

Когда использовать:  
- Запросы на равенство (`=`)  
- Диапазонные запросы (`<`, `<=`, `>`, `>=`)  
- Сортировка (`ORDER BY`)  
- Поиск по шаблону (`LIKE 'prefix%'`)
Может использоваться для получения данных в отсортированном порядке.

**Hash индексы**
Оптимизированы только для запросов на точное равенство.

**GIN индексы (Generalized Inverted Index)**
Предназначены для индексирования составных значений: массивов, JSON, полнотекстового поиска. Инвертированный индекс содержит отдельный элемент для значения каждого компонента, и может эффективно работать в запросах, проверяющих присутствие определённых значений компонентов.

**GiST индексы (Generalized Search Tree)**
Используются для геометрических данных, полнотекстового поиска, диапазонов.

**BRIN индексы (Block Range Index)**
Эффективны для больших таблиц с естественной сортировкой данных.
BRIN-индексы хранят обобщённые сведения о значениях, находящихся в физически последовательно расположенных блоках таблицы.

**Покрывающие индексы с INCLUDE**
INCLUDE индексы (покрывающие индексы) позволяют добавлять дополнительные столбцы в индекс без их индексирования. Эти столбцы хранятся только в листовых узлах B-Tree и не участвуют в навигации по дереву.

Основные преимущества INCLUDE индексов:

- Возможность выполнения Index-Only Scan (сканирование только индекса)
- Снижение количества обращений к основной таблице (heap)
- Включение столбцов любых типов данных (даже неиндексируемых)
- Более компактные верхние уровни индекса
- Уменьшение размера индекса по сравнению с полным составным индексом

Когда использовать:

- Частые запросы с фиксированным набором полей в SELECT
- Аналитические и отчетные запросы
- Lookup операции

**Составные индексы**
Индексы можно создавать по нескольким столбцам.

**Соединение индексов**
Процесс объединения индексов
1. Система создаёт битовые карты для каждого индекса. 
2. Битовые карты объединяются операциями AND и OR. 
3. Данные возвращаются в физическом порядке, что может потребовать дополнительной сортировки

**Уникальные индексы**
Индексы также могут обеспечивать уникальность значения в столбце или уникальность сочетания значений в нескольких столбцах. Если индекс создаётся как уникальный, в таблицу нельзя будет добавить несколько строк с одинаковыми значениями ключа индекса.

**Индексы по выражениям**
Индекс можно создать не только по столбцу нижележащей таблицы, но и по функции или скалярному выражению с одним или несколькими столбцами таблицы.

**Частичные индексы**
_Частичный индекс_ — это индекс, который строится по подмножеству строк таблицы, определяемому условным выражением (оно называется _предикатом_ частичного индекса). Такой индекс содержит записи только для строк, удовлетворяющих предикату.
## Транзакции в PSQL

Транзакция - множество операций, которые переводят бд из одного корректного состояния в другое корректное, при условии что транзакция выполнена полностью и без помех со стороны других транзакций. Другими словами - логическая единица работы, которая либо выполняется полностью, либо не выполняется вовсе.
```
Begin; -- начало транзакции
	--операции бд
	insert into ...
	values ...
	savepoint <name> -- точка сохранения
	update ... set ...
commit; -- фиксация изменений
rollback; -- отмена изменений
rollback to savepoint <name>
```
Точки сохранения позволяют выборочно отменять некоторые части транзакции и фиксировать все остальные.
## ACID принципы в PostgreSQL

**ACID** - набор требований которые обеспечивают сохранность и целостность данных.

**Atomicity (Атомарность)**
Атомарность гарантирует, что транзакция выполняется полностью или не выполняется вовсе.

**Consistency (Согласованность)**
Согласованность обеспечивает соблюдение всех ограничений целостности. То есть если есть ограничение, что столбец balance > 0, то это ограничение должно выполняться на каждом шаге транзакции.

Isolation ([[Изолированность]])
Транзакции должны выполняться изолированно друг от друга, и при параллельной работе не влиять друг на друга.

Durability (Долговечность)
Все данные которые записаны уже выполненной транзакцией, не будут отменены. 

PostgreSQL обеспечивает долговечность через WAL (Write-Ahead Logging).

## Методы партицирования в PostgreSQL

PostgreSQL поддерживает три основных метода партицирования:

**Партицирование по диапазону (RANGE)**
Самый распространенный метод, где данные разделяются по диапазонам значений.
```
CREATE TABLE sales();

CREATE TABLE sales_2024_q1 PARTITION OF sales FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');
```
**Партицирование по списку (LIST)**
Данные распределяются по конкретным значениям поля.

```
create table products();

CREATE TABLE products_electronics PARTITION OF products FOR VALUES IN ('Electronics' 'Computers', 'Mobile');
```

**Хеш-партицирование (HASH)**
Данные распределяются равномерно по партициям на основе хеш-функции. Таблица секционируется по определённым модулям и остаткам, которые указываются для каждой секции.
```
create table orders ();

CREATE TABLE orders_hash_0 PARTITION OF orders FOR VALUES WITH (MODULUS 3, REMAINDER 0);
```

#### Работа с данными
Вставка данных:
`INSERT INTO measurements VALUES`  
`(DEFAULT, 1, '2024-01-15', 23.5, 45.2),`  
`(DEFAULT, 2, '2024-02-10', 18.7, 38.9),`  
`(DEFAULT, 3, '2024-03-05', 25.1, 52.3);`

Запросы к партиционированной таблице:
`SELECT * FROM measurements`  
`WHERE measured_on BETWEEN '2024-01-01' AND '2024-01-31';`

##### Управление партициями
Добавление новой партиции:
`CREATE TABLE measurements_2024_04 PARTITION OF measurements`  
`FOR VALUES FROM ('2024-04-01') TO ('2024-05-01');`

Подключение существующей таблицы как партиции:
`-- Создаем обычную таблицу с подходящей структурой`  
`CREATE TABLE measurements_archive AS SELECT * FROM measurements WHERE false;`

`-- Подключаем как партицию`  
`ALTER TABLE measurements ATTACH PARTITION measurements_archive`  
`FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');`

Отключение партиции:
`ALTER TABLE measurements DETACH PARTITION measurements_2024_01;`

Удаление старых данных:
`DROP TABLE measurements_2024_01;`

#### Индексы и ограничения
Создание индексов:
`-- Индекс на родительской таблице создает индексы на всех партициях`  
`CREATE INDEX idx_measurements_sensor_date`  
`ON measurements (sensor_id, measured_on);`

`-- Уникальные индексы должны включать ключ партицирования`  
`CREATE UNIQUE INDEX idx_measurements_unique`  
`ON measurements (id, measured_on);`

Проверочные ограничения:
`-- Ограничения автоматически создаются для партиций`  
`ALTER TABLE measurements_2024_01`  
`ADD CONSTRAINT check_positive_temp`  
`CHECK (temperature > -50 AND temperature < 100);`

#### Мониторинг и оптимизация
Просмотр информации о партициях:
`-- Список всех партиций`  
`SELECT`  
    `schemaname,`  
    `tablename,`  
    `partitionname,`  
    `partitionboundary`  
`FROM pg_partitions`  
`WHERE tablename = 'measurements';`

`-- Размеры партиций`  
`SELECT`  
    `schemaname,`  
    `tablename,`  
    `pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size`  
`FROM pg_tables`  
`WHERE tablename LIKE 'measurements_%';`

Статистика использования:
`-- Количество строк в каждой партиции` 
`SELECT`  
    `schemaname||'.'||tablename as partition_name,`  
    `n_tup_ins as inserts,`  
    `n_tup_upd as updates,`  
    `n_tup_del as deletes`  
`FROM pg_stat_user_tables`  
`WHERE tablename LIKE 'measurements_%';`

## Оптимизация запросов
Эффективное выполнение SQL- запросов в PSQL позволяет сущетсвенно снизить время отклика приложения и нагрузку на сервер.

Основой любой оптимизации является анализ плана выполнения (execution plan), который показывает, как движок базы данных выполняет запрос.

### Сбор информации о плане выполнения

План выполнения запроса - древовидная структура, говорит о том, что база готова нам рассказать.

**EXPLAIN** показывает план без выполнения запроса.
**EXPLAIN ANALYZE** выполняет запрос и выводит фактические затраты времени и количество строк на каждом шаге.

#### Параметры
 ANALYZE: выполняет оператор и выводит фактическое время выполнения и статистику. 

- VERBOSE: выводит дополнительную информацию о плане запроса. 
    
- COSTS: выводит рассчитанную стоимость и число строк для каждого узла плана. 
    
- SETTINGS: выводит информацию о параметрах конфигурации, влияющих на планирование. 
    
- GENERIC_PLAN: создаёт общий план, не зависящий от значений параметров. 
    
- BUFFERS: включает информацию об использовании буфера. 
    
- SERIALIZE: включает информацию о стоимости сериализации выходных данных. 
    
- WAL: включает информацию о формировании записей WAL. 
    
- TIMING: включает фактическое время запуска и время выполнения каждого узла. 
    
- SUMMARY: включает сводку после плана запроса. 
    
- MEMORY: выводит информацию о потреблении памяти на этапе планирования. 
    
- FORMAT: устанавливает формат вывода (TEXT, XML, JSON, YAML).

#### Пример:
`EXPLAIN ANALYZE SELECT * FROM orders o JOIN customers c ON o.customer_id = c.id WHERE o.order_date >= '2024-01-01';`
Результат содержит для каждого узла дерева:
- Тип операции (Seq Scan, Index Scan, Hash Join и т. д.)
- Оценка затрат времени (cost=…)
- Фактическое время выполнения (actual time=…)
- Количество обработанных строк (rows=…)
- Буферные метрики (при использовании опции BUFFERS)
### Понимание основных узлов плана
**Seq Scan (последовательный обход)**  
Чтение всей таблицы. Используется, когда нет подходящего индекса или предикаты сильно селективны. Часто медленно на больших объёмах данных.

**Index Scan / Index Only Scan**  
Поиск по индексу. Быстрее Seq Scan при хорошем селективном условии. Index Only Scan может не обращаться к данным, если индекс покрывает все нужные столбцы.

**Bitmap Heap Scan + Bitmap Index Scan**  
Сначала строится bitmap выбранных строк по индексу, затем считываются нужные страницы из таблицы. Эффективно для среднеселективных условий.

**Join-операции**
- Nested Loop — вложенный цикл; хорошо при малом количестве строк во внешней таблице.
- Hash Join — строит хеш-таблицу для меньшей таблицы, затем выполняет поиск; эффективен для больших объёмов.
- Merge Join — сортирует строки по ключу и затем объединяет; хорош для уже отсортированных данных.

**Aggregate и Sort**  
Операции агрегации и сортировки могут потребовать значительной памяти (work_mem) и приводят к созданию временных файлов на диске, если памяти недостаточно.

### Основные приемы оптимизации
**Индексы**
- Создавайте индексы на колонках, часто используемых в WHERE, JOIN и ORDER BY.
- Используйте составные индексы для нескольких условий одновременно.
- Избегайте избыточных индексов — они замедляют INSERT/UPDATE/DELETE.

**Статистика**
Регулярно выполняйте ANALYZE (или VACUUM ANALYZE), чтобы статистика отражала актуальное распределение данных.

**Параметры памяти**
- Увеличьте work_mem для операций сортировки и хеширования, чтобы они выполнялись в памяти.
- Настройте shared_buffers и effective_cache_size для оптимального использования оперативной памяти.

**Переписывание запросов**
Разбейте сложные запросы на более простые, если оптимизатор плохо оценивает выборки.

**Партицирование и денормализация**
Для очень больших таблиц применяйте партицирование, чтобы план затрагивал только нужные партиции.

В редких случаях вводите денормализованные поля или материализованные представления для ускорения чтения.

## Виды партицирования PSQL
(далее секционирование)
### Декларативное секционирование
PostgreSQL позволяет декларировать, что некоторая таблица разделяется на секции. Разделённая на секции таблица называется _секционированной таблицей_.
Сама секционированная таблица является «виртуальной» и как таковая не хранится. Хранилище используется её _секциями_, которые являются обычными таблицами, связанными с секционированной. В каждой секции хранится подмножество данных таблицы, определяемое её _границами секции_. Все строки, вставляемые в секционированную таблицу, перенаправляются в соответствующие секции в зависимости от значений столбцов ключа секционирования. Если при изменении значений ключа секционирования в строке она перестаёт удовлетворять ограничениям исходной секции, эта строка перемещается в другую секцию.
### Секционирование с использованием наследования
В этом случае секционирование можно реализовать, применив механизм наследования таблиц, что даст ряд возможностей, неподдерживаемых при декларативном секционировании, например:
- При декларативном секционировании все секции должны иметь в точности тот же набор столбцов, что и секционируемая таблица, тогда как обычное наследование таблиц допускает наличие в дочерних таблицах дополнительных столбцов, отсутствующих в родителе.
- Механизм наследования таблиц поддерживает множественное наследование.
- С декларативным секционированием поддерживается только секционирование по спискам, по диапазонам и по хешу, тогда как с наследованием таблиц данные можно разделять по любому критерию, выбранному пользователем.